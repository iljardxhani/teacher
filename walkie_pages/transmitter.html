<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Walkie Transmitter</title>
  <style>
    :root {
      --bg: #f4f7fb;
      --card: #ffffff;
      --text: #122230;
      --muted: #6a7785;
      --ok: #0f9d5f;
      --warn: #c07b10;
      --accent: #0e74c7;
      --danger: #b62222;
      --border: #d6deea;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: linear-gradient(160deg, #f7fbff, #eaf2fa);
      color: var(--text);
      min-height: 100vh;
      padding: 16px;
    }
    .card {
      max-width: 560px;
      margin: 0 auto;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 18px rgba(35, 62, 89, 0.08);
    }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .muted { color: var(--muted); }
    .row { display: flex; gap: 8px; margin-top: 12px; }
    input {
      flex: 1;
      min-width: 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      font-size: 17px;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    button {
      border: 1px solid #0e5f9f;
      background: var(--accent);
      color: #fff;
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 15px;
      cursor: pointer;
    }
    .pill {
      display: inline-block;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 5px 10px;
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
      background: #f8fbff;
    }
    .pill.ok { color: var(--ok); border-color: #93d4b6; }
    .pill.warn { color: var(--warn); border-color: #e3c690; }
    .talk-wrap { margin-top: 16px; }
    .talk-btn {
      width: 100%;
      min-height: 190px;
      border-radius: 16px;
      border: 2px solid #af2222;
      background: radial-gradient(circle at 50% 35%, #ff6868, #db2f2f);
      color: #fff;
      font-size: 28px;
      font-weight: 700;
      user-select: none;
      touch-action: none;
    }
    .talk-btn.active {
      border-color: #7f1111;
      background: radial-gradient(circle at 50% 35%, #ff3d3d, #b80f0f);
      transform: scale(0.99);
    }
    .talk-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    pre {
      margin-top: 12px;
      white-space: pre-wrap;
      background: #f5f8fc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      max-height: 180px;
      overflow: auto;
      font-size: 12px;
      color: #3a4d60;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Walkie Transmitter</h1>
    <div class="muted">Enter pair code from receiver tab, connect, then hold button to speak.</div>
    <div id="secureWarn" class="muted" style="margin-top:8px"></div>

    <div class="row">
      <input id="pairCodeInput" placeholder="PAIR CODE" maxlength="6" inputmode="numeric" />
      <button id="connectBtn">Connect</button>
    </div>

    <div id="sessPill" class="pill">session: idle</div>
    <div id="connPill" class="pill">webrtc: idle</div>

    <div class="talk-wrap">
      <button id="talkBtn" class="talk-btn" disabled>PRESS TO SPEAK</button>
    </div>

    <pre id="logBox"></pre>
  </div>

  <script>
    const pairCodeInput = document.getElementById("pairCodeInput");
    const connectBtn = document.getElementById("connectBtn");
    const talkBtn = document.getElementById("talkBtn");
    const sessPill = document.getElementById("sessPill");
    const connPill = document.getElementById("connPill");
    const logBox = document.getElementById("logBox");
    const secureWarn = document.getElementById("secureWarn");

    const state = {
      sessionId: null,
      transmitterToken: null,
      pc: null,
      micStream: null,
      micTrack: null,
      pullBusy: false,
      connected: false,
      talking: false,
      closed: false,
      heartbeatTimer: null,
      answerApplied: false,
    };

    function log(msg, data) {
      const line = `[${new Date().toLocaleTimeString()}] ${msg}` + (data ? ` ${JSON.stringify(data)}` : "");
      logBox.textContent = `${line}\n${logBox.textContent}`.slice(0, 11000);
      console.log("[walkie-transmitter]", msg, data || "");
    }

    function setPill(el, text, klass = "") {
      el.textContent = text;
      el.className = `pill ${klass}`.trim();
    }

    async function postJson(path, payload) {
      const resp = await fetch(path, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload || {}),
      });
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok) {
        throw new Error(data.error || `HTTP ${resp.status}`);
      }
      return data;
    }

    async function pushSignal(type, payload, to) {
      if (!state.sessionId || !state.transmitterToken) return;
      await postJson("/walkie/api/signal/push", {
        session_id: state.sessionId,
        token: state.transmitterToken,
        to,
        type,
        payload: payload || {},
      });
    }

    function waitIceGatheringComplete(pc, timeoutMs = 6000) {
      if (pc.iceGatheringState === "complete") return Promise.resolve();
      return new Promise((resolve) => {
        let done = false;
        const finish = () => {
          if (done) return;
          done = true;
          pc.removeEventListener("icegatheringstatechange", onState);
          resolve();
        };
        const onState = () => {
          if (pc.iceGatheringState === "complete") finish();
        };
        pc.addEventListener("icegatheringstatechange", onState);
        setTimeout(finish, timeoutMs);
      });
    }

    async function ensureMic() {
      if (state.micStream && state.micTrack) return;
      state.micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      state.micTrack = state.micStream.getAudioTracks()[0] || null;
      if (!state.micTrack) {
        throw new Error("no_audio_track");
      }
      state.micTrack.enabled = false;
      log("microphone ready");
    }

    function ensurePeerConnection() {
      if (state.pc) return state.pc;
      const pc = new RTCPeerConnection();
      state.pc = pc;

      pc.onconnectionstatechange = () => {
        const cs = pc.connectionState || "unknown";
        const klass = cs === "connected" ? "ok" : (cs === "failed" || cs === "disconnected" ? "warn" : "");
        setPill(connPill, `webrtc: ${cs}`, klass);
        state.connected = cs === "connected";
        talkBtn.disabled = !state.connected;
        if (!state.connected) {
          setTalking(false);
        }
      };

      if (state.micTrack) {
        pc.addTrack(state.micTrack, state.micStream);
      }

      return pc;
    }

    async function createAndSendOffer() {
      const pc = ensurePeerConnection();
      const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
      await pc.setLocalDescription(offer);
      await waitIceGatheringComplete(pc);
      await pushSignal("offer", pc.localDescription, "receiver");
      log("offer sent");
    }

    async function applyAnswer(answerPayload) {
      if (!answerPayload || state.answerApplied) return;
      const pc = ensurePeerConnection();
      await pc.setRemoteDescription(answerPayload);
      state.answerApplied = true;
      log("answer applied");
    }

    async function handleSignal(msg) {
      if (!msg || typeof msg !== "object") return;
      const type = String(msg.type || "");
      if (type === "answer") {
        await applyAnswer(msg.payload);
      }
    }

    async function pullLoop() {
      if (!state.sessionId || !state.transmitterToken || state.closed || state.pullBusy) return;
      state.pullBusy = true;
      try {
        const url = `/walkie/api/signal/pull?session_id=${encodeURIComponent(state.sessionId)}&token=${encodeURIComponent(state.transmitterToken)}&timeout_ms=25000`;
        const resp = await fetch(url);
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          throw new Error(data.error || `HTTP ${resp.status}`);
        }
        const msgs = Array.isArray(data.messages) ? data.messages : [];
        for (const m of msgs) {
          try {
            await handleSignal(m);
          } catch (err) {
            log("signal handle failed", { err: String(err), type: m && m.type });
          }
        }
      } catch (err) {
        log("pull failed", { err: String(err) });
        await new Promise((r) => setTimeout(r, 800));
      } finally {
        state.pullBusy = false;
        if (!state.closed) setTimeout(pullLoop, 30);
      }
    }

    async function connect() {
      const pairCode = String(pairCodeInput.value || "").replace(/\D+/g, "").slice(0, 6);
      if (!pairCode) throw new Error("pair_code_required");

      setPill(sessPill, "session: joining");
      const join = await postJson("/walkie/api/session/join", { pair_code: pairCode });
      state.sessionId = join.session_id;
      state.transmitterToken = join.transmitter_token;
      state.answerApplied = false;
      setPill(sessPill, "session: connected", "ok");
      log("joined session", { session_id: join.session_id });

      await ensureMic();
      ensurePeerConnection();
      await createAndSendOffer();
      pullLoop();

      if (state.heartbeatTimer) clearInterval(state.heartbeatTimer);
      state.heartbeatTimer = setInterval(() => {
        pushSignal("heartbeat", { ts_ms: Date.now() }, "receiver").catch(() => {});
      }, 10000);
    }

    function setTalking(on) {
      const next = Boolean(on && state.connected && state.micTrack);
      if (state.talking === next && state.micTrack) {
        state.micTrack.enabled = next;
        return;
      }
      state.talking = next;
      if (state.micTrack) {
        state.micTrack.enabled = next;
      }
      talkBtn.classList.toggle("active", next);
      pushSignal("ptt_state", { pressed: next, ts_ms: Date.now() }, "receiver").catch(() => {});
    }

    function bindTalkButton() {
      const off = () => setTalking(false);
      talkBtn.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        if (!state.connected) return;
        setTalking(true);
      });
      talkBtn.addEventListener("pointerup", off);
      talkBtn.addEventListener("pointercancel", off);
      talkBtn.addEventListener("pointerleave", off);
      window.addEventListener("blur", off);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) off();
      });
    }

    connectBtn.addEventListener("click", async () => {
      connectBtn.disabled = true;
      try {
        await connect();
      } catch (err) {
        setPill(sessPill, "session: failed", "warn");
        log("connect failed", { err: String(err) });
      } finally {
        connectBtn.disabled = false;
      }
    });

    window.addEventListener("beforeunload", () => {
      state.closed = true;
      setTalking(false);
      if (state.heartbeatTimer) clearInterval(state.heartbeatTimer);
      if (state.sessionId && state.transmitterToken) {
        fetch("/walkie/api/session/close", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: state.sessionId, token: state.transmitterToken }),
          keepalive: true,
        }).catch(() => {});
      }
      if (state.pc) {
        try { state.pc.close(); } catch (_) {}
      }
      if (state.micStream) {
        for (const t of state.micStream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
    });

    (function init() {
      if (!window.isSecureContext) {
        secureWarn.textContent = "Mic access may fail on insecure HTTP. Open this page over HTTPS.";
        secureWarn.style.color = "#b62222";
      } else {
        secureWarn.textContent = "Secure context detected.";
        secureWarn.style.color = "#0f9d5f";
      }
      bindTalkButton();
      const fromQuery = new URLSearchParams(window.location.search).get("pair_code");
      if (fromQuery) pairCodeInput.value = fromQuery;
    })();
  </script>
</body>
</html>
